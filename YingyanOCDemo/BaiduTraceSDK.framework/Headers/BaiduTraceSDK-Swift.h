// Generated by Apple Swift version 2.3 (swiftlang-800.10.12 clang-800.0.38)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import CoreLocation;
@import Foundation;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSData;


/// entity相关的协议,包括创建实体对象、更新实体对象、检索实体对象等请求的回调方法
SWIFT_PROTOCOL("_TtP13BaiduTraceSDK25ApplicationEntityDelegate_")
@protocol ApplicationEntityDelegate
@optional

/// addEntity(_:serviceId:entityName:columnKey:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的<a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/entity">entity/add</a>接口的返回值
///
/// \param data 创建实体对象的结果
- (void)onAddEntity:(NSData * _Nonnull)data;

/// updateEntity(_:serviceId:entityName:columnKey:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的<a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/entity#update.E2.80.94.E2.80.94.E6.9B.B4.E6.96.B0entity.E4.BF.A1.E6.81.AF">entity/update</a>接口的返回值
///
/// \param data 更新实体对象的结果
- (void)onUpdateEntity:(NSData * _Nonnull)data;

/// queryEntityList(_:serviceId:entityNames:columnKey:activeTime:returnType:pageSize:pageIndex:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的<a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/entity#list.E2.80.94.E2.80.94.E6.9F.A5.E8.AF.A2entity">entity/list</a>接口的返回值
///
/// \param data 查询实体对象的结果
- (void)onQueryEntityList:(NSData * _Nonnull)data;
@end



/// ApplicationFenceDelegate 协议包含服务端地理围栏的增删改查以及围栏状态、历史报警信息等请求的回调方法
SWIFT_PROTOCOL("_TtP13BaiduTraceSDK24ApplicationFenceDelegate_")
@protocol ApplicationFenceDelegate
@optional

/// createCircularFence(_:serviceId:fenceName:fenceDesc:creator:monitoredPersons:observers:validTimes:validCycle:validDate:validDays:coordType:center:radius:alarmCondition:precision:) 方法和 createVertexesFence(_:serviceId:fenceName:fenceDesc:creator:monitoredPersons:observers:validTimes:validCycle:validDate:validDays:coordType:vertexes:alarmCondition:precision:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/fence#create.E2.80.94.E2.80.94.E5.88.9B.E5.BB.BA.E5.9C.B0.E7.90.86.E5.9B.B4.E6.A0.8F">fence/create</a> 接口的返回值
///
/// \param data 创建服务端地理围栏的结果
- (void)onCreateFence:(NSData * _Nonnull)data;

/// createLocalFence(_:fence:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，创建成功会返回fence_id
///
/// \param data 创建客户端地理围栏的结果
- (void)onCreateLocalFence:(NSData * _Nonnull)data;

/// deleteLocalFence(_:fenceId:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData
///
/// \param data 删除客户端地理围栏的结果
- (void)onDeleteLocalFence:(NSData * _Nonnull)data;

/// updateFence(_:serviceId:fenceId:fenceName:fenceDesc:monitoredPersons:observers:validTimes:validCycle:validDate:validDays:shape:coordType:center:radius:vertexes:alarmCondition:precision:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/fence#update.E2.80.94.E2.80.94.E6.9B.B4.E6.96.B0.E5.9B.B4.E6.A0.8F">fence/update</a> 接口的返回值
///
/// \param data 更新服务端地理围栏的结果
- (void)onUpdateFence:(NSData * _Nonnull)data;

/// deleteFence(_:serviceId:fenceId:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/fence#delete.E2.80.94.E2.80.94.E5.88.A0.E9.99.A4.E5.9B.B4.E6.A0.8F">fence/delete</a> 接口的返回值
///
/// \param data 删除服务端地理围栏的结果
- (void)onDeleteFence:(NSData * _Nonnull)data;

/// queryFenceList(_:serviceId:creator:fenceIds:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/fence#list.E2.80.94.E2.80.94.E6.9F.A5.E8.AF.A2.E5.9B.B4.E6.A0.8F">fence/list</a> 接口的返回值
///
/// \param data 查询服务端地理围栏的结果
- (void)onFenceList:(NSData * _Nonnull)data;

/// queryFenceStatus(_:serviceId:fenceId:monitoredPersons:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/fence#querystatus.E2.80.94.E2.80.94.E6.9F.A5.E8.AF.A2.E5.9B.B4.E6.A0.8F.E5.86.85.E7.9B.91.E6.8E.A7.E5.AF.B9.E8.B1.A1.E7.8A.B6.E6.80.81">fence/querystatus</a> 接口的返回值
///
/// \param data 查询指定的被监控对象的状态的结果
- (void)onQueryFenceStatus:(NSData * _Nonnull)data;

/// queryFenceHistoryAlarm(_:serviceId:fenceId:monitoredPersons:beginTime:endTime:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/fence#historyalarm.E2.80.94.E2.80.94.E6.9F.A5.E8.AF.A2.E5.9B.B4.E6.A0.8F.E5.86.85.E7.9B.91.E6.8E.A7.E5.AF.B9.E8.B1.A1.E5.8E.86.E5.8F.B2.E6.8A.A5.E8.AD.A6.E4.BF.A1.E6.81.AF">fence/historyalarm</a> 接口的返回值
///
/// \param data 查询指定的地理围栏历史报警的结果
- (void)onQueryFenceHistoryAlarm:(NSData * _Nonnull)data;
@end



/// 轨迹服务的协议,包括轨迹服务相关的回调方法
///
/// <h3>Important Notes</h3>
/// <ul><li>遵守 <code>ApplicationServiceDelegate
/// </code> 的类，可以接收服务开启、服务结束的回调。</li><li>遵守 <code>ApplicationServiceDelegate
/// </code> 的类，也可以接收服务运行时修改采集和打包周期的回调。</li><li>自定义字段的上传，也需要实现本协议中的 <code>trackAttr()
/// </code> 回调方法。</li></ul>
SWIFT_PROTOCOL("_TtP13BaiduTraceSDK26ApplicationServiceDelegate_")
@protocol ApplicationServiceDelegate
@optional

/// 开始轨迹服务的回调方法
///
/// <h3>状态码和状态信息的对应关系如下</h3>
/// <ul><li>0代表开始追踪成功，当前已登陆到服务器</li><li>1代表内部错误</li><li>10002代表参数错误</li><li>10003代表当前模式为不建立长连接，不能开启追踪服务</li><li>10007代表开始追踪成功，当前未登陆到服务器，当前模式为UPLOADLOCATION, 已经开始缓存数据</li><li>10008代表开始追踪成功，当前未登陆到服务器，当前模式为NOUPLOADLOCATION, 当网络连接正常时会自动重新登陆</li><li>10010代表正在开启服务</li><li>10011代表正在结束服务</li></ul>
/// <h3>Note</h3>
/// <ul><li>轨迹服务的开启过程需要一定的时间</li><li>由于历史原因，状态码和状态信息分别采用Int和String类型。v3.0版本的SDK可能会改为泛型枚举等标准Swift的方式来提供异步API的状态，具体实现方式依赖未来版本的Swift和OC的桥接支持程度</li></ul>
/// \param errNo 开始轨迹服务的状态码
///
/// \param errMsg 开始轨迹服务的状态信息
- (void)onStartTrace:(NSInteger)errNo errMsg:(NSString * _Nonnull)errMsg;

/// 获取自定义字段的值的回调方法，SDK会在每个采集周期回调此方法，将其返回值作为当前采集周期的轨迹点的自定义字段。
///
/// <h3>Note</h3>
/// <ul><li>在轨迹服务运行期间，此方法将在每个采集周期被SDK调用一次，遵循 <code>ApplicationServiceDelegate
/// </code> 协议的类，只有需要为轨迹点附加自定义数据时，才需要实现此方法。</li><li>每个采集周期对应轨迹点的速度、方向、高度、定位精度的值，作为轨迹数据的一部分，SDK会自动采集，不需要额外实现此方法去指定。</li><li>SDK会解析此方法返回的字典，将key认为是自定义字段的名称，将value认为是自定义字段的值。需要注意的是，字典中的key必须先通过鹰眼webapi的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/track#addcolumn.E2.80.94.E2.80.94.E6.B7.BB.E5.8A.A0track.E7.9A.84.E5.B1.9E.E6.80.A7.E5.AD.97.E6.AE.B5">track/addcolumn</a> 接口添加过才有效。</li></ul>
/// <h3>最佳实践</h3>
/// 每个轨迹点都可能有一些和具体业务相关的数据，可以通过此方法将这些数据作为轨迹点的自定义数据“附加”到这个轨迹点上。比如当前在开发一款跑步类的APP，可能需要记录每个轨迹点所对应的心率信息，那么可以通过以下几个步骤实现这一点。
///
/// <ol><li>通过鹰眼webapi的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/track#addcolumn.E2.80.94.E2.80.94.E6.B7.BB.E5.8A.A0track.E7.9A.84.E5.B1.9E.E6.80.A7.E5.AD.97.E6.AE.B5">track/addcolumn</a> 接口添加一个叫做<code>heart_rate
/// </code>的字段.</li><li>通过心率带或带有心率检测功能的外部设备获取心率，并通过其相应的接口将心率数据传入APP</li><li>定义一个字典类型的变量，包含一个名为<code>heart_rate
/// </code>的键，并设置其初始值。假设为additional_data['heart_rate'] = 60。</li><li>每当APP获取到最新的心率数据时，更新这个字典中<code>heart_rate
/// </code>的值为最新的心率数据。</li><li><code>trackAttr()
/// </code>方法的实现非常简单，只需要return这个字典即可。</li><li>通过以上步骤，SDK在每个采集周期回调这个方法时，就获取到了最新的心率数据，并将此心率数据“附加”在了当前的轨迹点上。无论是通过 <code>queryEntityList(_:serviceId:entityNames:columnKey:activeTime:returnType:pageSize:pageIndex:)
/// </code> 方法查询实时位置，还是通过<code>getTrackHistory
/// </code>方法查询历史轨迹，这些心率数据都会作为轨迹的“附加”数据呈现出来。</li></ol>
/// \returns  自定义字段的字典
- (NSDictionary<NSString *, NSString *> * _Nullable)trackAttr;

/// 结束轨迹服务的回调方法
///
/// <h3>状态码和状态信息的对应关系如下</h3>
/// <ul><li>0 代表停止成功</li><li>11002 代表还没开始，无法停止</li><li>11004 代表正在开始，无法停止</li><li>11005 代表正在结束服务</li><li>10006 代表当前类型为不建立长连接, 无法停止追踪</li></ul>
/// <h3>Note</h3>
/// <ul><li>轨迹服务的结束过程需要一定的时间。</li><li>若当前没有缓存数据需要上传，或者当前有缓存数据待上传，但网络不通，服务的结束最多需要等待一个采集周期的时间。</li><li>若当前有较多的缓存数据待上传，且当前网络畅通，会把所有的缓存数据上传完毕后才能结束，因此需要的时间可能比较久。</li><li>由于历史原因，状态码和状态信息分别采用Int和String类型。v3.0版本的SDK可能会改为泛型枚举等标准Swift的方式来提供异步API的状态，具体实现方式依赖未来版本的Swift和OC的桥接支持程度</li></ul>
/// \param errNo 开始轨迹服务的状态码
///
/// \param errMsg 开始轨迹服务的状态信息
- (void)onStopTrace:(NSInteger)errNo errMsg:(NSString * _Nonnull)errMsg;

/// 推送信息的回调方法，当收到来自服务端的推送消息（比如地理围栏的触发消息）时，SDK会回调此方法
///
/// <h3>msgType字段的值代表的推送消息类型</h3>
/// <ul><li>0x01：配置下发;</li><li>0x02：语音消息;</li><li>0x03：服务端地理围栏报警消息;</li><li>0x04：客户端地理围栏报警消息;</li><li>0x05~0x40：系统预留;</li><li>0x41~0xFF：开发者自定义;</li></ul>
/// <h3>msgType为报警推送时，msgContent字段中JSON字段的说明</h3>
/// <ul><li>fence_id 触发报警的服务端地理围栏的唯一标识</li><li>fence 触发报警的服务端地理围栏的名称</li><li>monitored_person 触发报警的地理围栏所监控的entity的名称</li><li>action 被监控对象进出围栏的动作 1代表进入围栏 2代表离开围栏</li><li>time 代表地理围栏被触发的时间</li></ul>
/// \param msgType 推送消息的类型
///
/// \param msgContent 推送消息的内容，JSON格式的字符串类型
- (void)onPushTrace:(uint8_t)msgType msgContent:(NSString * _Nonnull)msgContent;

/// 轨迹服务开始后调用 changeGatherAndPackIntervalsAfterStartTrace(_:gatherInterval:packInterval:) 方法改变采集和打包周期后的回调方法
///
/// <h3>状态码和状态信息的对应关系如下</h3>
/// <ul><li>0 设置成功</li><li>1 设置失败</li><li>2 参数错误</li><li>3 当前模式为不采集和上传位置数据</li><li>4 本方法需要先startTrace再调用</li></ul>
/// \param errNo 改变周期后的状态码
///
/// \param errMsg 改变周期的状态信息
- (void)onChangeGatherAndPackIntervalsAfterStartTrace:(NSInteger)errNo errMsg:(NSString * _Nonnull)errMsg;
@end



/// ApplicationTrackDelegate 协议包含历史轨迹查询以及里程查询的回调方法
SWIFT_PROTOCOL("_TtP13BaiduTraceSDK24ApplicationTrackDelegate_")
@protocol ApplicationTrackDelegate
@optional

/// getTrackHistory(_:serviceId:entityName:startTime:endTime:simpleReturn:isProcessed:processOption:supplementMode:sortType:pageSize:pageIndex:) 方法以及 getTrackHistory(_:serviceId:entityName:startTime:endTime:simpleReturn:isProcessed:pageSize:pageIndex:)  方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/track#gethistory.E2.80.94.E2.80.94.E6.9F.A5.E8.AF.A2.E5.8E.86.E5.8F.B2.E8.BD.A8.E8.BF.B9">track/gethistory</a> 接口的返回值
///
/// \param data 查询指定实体对象的历史轨迹的结果
- (void)onGetHistoryTrack:(NSData * _Nonnull)data;

/// queryDistance(_:serviceId:entityName:isProcessed:processOption:supplementMode:startTime:endTime:) 方法的回调方法
///
/// <h3>Note:</h3>
/// 按照JSON格式去解析返回的NSData，返回的格式请参考鹰眼WEB-API的 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/track#gethistory.E2.80.94.E2.80.94.E6.9F.A5.E8.AF.A2.E5.8E.86.E5.8F.B2.E8.BD.A8.E8.BF.B9">track/gethistory</a> 接口当指定isProcessed=2时的返回值
///
/// \param data 查询指定实体对象在指定时间短内的里程的结果
- (void)onQueryDistance:(NSData * _Nonnull)data;
@end



/// 客户端地理围栏信息类，使用客户端地理围栏之前需要先实例化BLocalFence类。
///
/// <h3>Note:</h3>
/// <ul><li>目前客户端地理围栏仅支持圆形围栏。</li><li>客户端地理围栏的创建、删除、触发计算、报警推送都在客户端进行，不受网络连通状态的限制。</li><li>由于客户端地理围栏的运行完全都在客户端进行，和服务端地理围栏没有任何关系。所以即使设置了圆心和半径以及去燥精度完全相同的客户端和服务端地理围栏，完全有可能一个报警，另一个不报警。</li><li>客户端地理围栏是为了对服务端地理围栏进行补充，有的情况下，设备可能在较长时间都处于离线状态，此时SDK虽然会对轨迹进行缓存，但由于无法讲轨迹数据上传回服务端，所以无法触发服务端的地理围栏。客户端地理围栏在断网状态下仍然可以正常计算及推送报警。</li><li>用户可以既创建客户端地理围栏，又创建服务端地理围栏。接收到它们的报警推送后，根据自身的业务场景，决定以客户端地理围栏的报警为准，还是服务端围栏的报警为准，或者综合考虑作出判断。</li></ul>
SWIFT_CLASS("_TtC13BaiduTraceSDK11BLocalFence")
@interface BLocalFence : NSObject

/// BLocalFence类的构造函数，目前客户端地理围栏只支持圆形地理围栏，通过此构造函数创建出来的客户端地理围栏是圆形的。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>let loc = CLLocationCoordinate2D(latitude: 40.0, longitude: 116.0)
/// let lf = BLocalFence(name: "fenceA", center: loc, coordType: 3, radius: 10, accuracy: 10)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>CLLocationCoordinate2D center = CLLocationCoordinate2DMake(40.0, 116.0);
/// BLocalFence* localFence = [[BLocalFence alloc] initWithName:@"fenceA" center:center coordType:3 radius:50 accuracy: 50];
/// 
/// </code>
/// \param name 圆形地理围栏的名称
///
/// \param center 圆形地理围栏的圆心
///
/// \param coordType 圆心的坐标类型
///
/// \param radius 圆形地理围栏的半径，单位为米
///
/// \param accuracy 地理围栏去燥的精度，若采集到的轨迹点的定位精度大于此值，则不会进行客户端围栏的计算，也就不会触发客户端地理围栏的报警。如果希望所有采集到的轨迹点都进行客户端围栏的计算，将此字段的值设为0。
///
/// \returns  <code>BLocalFence
/// </code>类的对象
- (nonnull instancetype)initWithName:(NSString * _Nonnull)name center:(CLLocationCoordinate2D)center coordType:(uint8_t)coordType radius:(double)radius accuracy:(NSInteger)accuracy OBJC_DESIGNATED_INITIALIZER;
@end



/// 轨迹服务信息类
///
/// <h3>Important Notes</h3>
/// <ul><li><code>BTRACE
/// </code> 类包含了SDK运行所需要的重要信息，是使用SDK的基础</li><li>访问SDK的任何方法前，都必需先实例化 <code>BTRACE
/// </code> 类</li></ul>
SWIFT_CLASS("_TtC13BaiduTraceSDK6BTRACE")
@interface BTRACE : NSObject

/// BTRACE类的构造函数\Warning 
///
/// 
///
/// <ul><li>使用SDK的任何方法之前，都必须先实例化 <code>BTRACE
/// </code> 类。如果在实例化 <code>BTRACE
/// </code> 类之前调用SDK中的其他方法，会导致开启轨迹服务失败，查询轨迹、创建围栏等操作报错等各种问题</li><li><code>BTRACE
/// </code>类初始化失败只可能有一种原因，就是SDK没有被正确的导入。如果出现<code>BTRACE
/// </code>类初始化后的结果为nil的情况，请检查SDK的导入步骤是否正确。</li></ul>
/// <h3>Notes:</h3>
/// <ol><li>此处的ak必须是在 <a href="http://lbsyun.baidu.com/apiconsole/key">API控制台</a> 申请的iOS类型的ak</li><li>serviceId参数并非申请ak时的应用编号，而是在 <a href="http://lbsyun.baidu.com/index.php?title=yingyan/manage">鹰眼轨迹管理台</a> 创建鹰眼服务之后，分配的service_id</li><li>开始轨迹服务后，SDK所采集到的轨迹都属于此处的entityName名下</li></ol>
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>let traceInstance = BTRACE(ak: "aa", mcode: "bb", serviceId: 123, entityName: "aa", operationMode: 2)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>BTRACE * traceInstance = NULL;
/// traceInstance = [[BTRACE alloc] initWithAk: @"aa" mcode: @"bb" serviceId: 123 entityName: @"aa" operationMode: 2];
/// 
/// </code>
/// \param ak 从API控制台申请应用时分配的ak
///
/// \param mcode 申请ak时填写的安全码
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param entityName 被监控对象的名称
///
/// \param operationMode 轨迹服务的类型 <code>0
/// </code>:不建立长连接  <code>1
/// </code>:建立长连接但不采集数据  <code>2
/// </code>:建立长连接并采集数据
///
/// \returns  <code>BTRACE
/// </code>类的对象
- (nonnull instancetype)initWithAk:(NSString * _Nonnull)ak mcode:(NSString * _Nonnull)mcode serviceId:(long long)serviceId entityName:(NSString * _Nonnull)entityName operationMode:(NSInteger)operationMode OBJC_DESIGNATED_INITIALIZER;

/// 设置轨迹服务的采集周期和打包周期
///
/// <h3>Notes</h3>
/// <ul><li>轨迹服务会在每个采集周期采集当前的位置数据，并在每个打包周期将这些轨迹打包、压缩、加密之后上传至服务端</li><li>实例化 <code>BTRACE
/// </code> 类之后，在调用 <code>startTrace(_:trace:)
/// </code> 方法之前，通过此方法设置轨迹服务的采集周期和打包周期</li><li>在startTrace开始轨迹服务之后，若想改变采集和打包周期，调用 <code>BTRACEAction
/// </code> 中的 <code>changeGatherAndPackIntervalsAfterStartTrace(_:gatherInterval:packInterval:)
/// </code> 方法</li></ul>
/// <h3>Requires</h3>
/// <ul><li>采集周期最小为2秒，最大为60秒</li><li>打包周期最小为2秒，最大为60秒</li><li>打包周期必须比采集周期大，且必须是采集周期的整数倍</li></ul>
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>//先实例化BTRACE类得到traceInstance对象
/// traceInstance.setInterval(2, packInterval: 10)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>//先实例化 `BTRACE` 类得到traceInstance对象
/// BOOL intervalSetRet = [traceInstance setInterval:2 packInterval:10];
/// 
/// </code>
/// <ul><li>requires 打包周期必须比采集周期大，且必须是采集周期的整数倍</li></ul>
/// \param gatherInterval 轨迹服务的采集周期
///
/// \param packInterval 轨迹服务的打包周期
///
/// \returns  设置成功或失败。true代表成功，false代表失败。
- (BOOL)setInterval:(int32_t)gatherInterval packInterval:(int32_t)packInterval;
@end



/// BTRACEAction 类中提供了SDK中所有方法的全局访问点，在实例化 BTRACE 类之后，才可以使用 BTRACEAction 类中的方法
SWIFT_CLASS("_TtC13BaiduTraceSDK12BTRACEAction")
@interface BTRACEAction : NSObject

/// BTRACEAction 类的全局访问点
+ (BTRACEAction * _Nonnull)shared;

/// 获取当前SDK的版本号
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.getCurrentVersion()
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] getCurrentVersion];
/// 
/// </code>
/// \returns  当前SDK的版本号
- (NSString * _Nonnull)getCurrentVersion;

/// 开始轨迹服务
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.startTrace(self, trace: traceInstance)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] startTrace:self trace:traceInstance];
/// 
/// </code>
/// \param delegate 遵循 <code>ApplicationServiceDelegate
/// </code> 协议的对象。开启轨迹服务的结果会通过 <code>onStartTrace(_:errMsg:)
/// </code> 方法进行回调
///
/// \param trace <code>BTRACE
/// </code>类的对象
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationServiceDelegate
/// </code> 协议中的 <code>onStartTrace(_:errMsg:)
/// </code> 回调方法获取
- (void)startTrace:(id <ApplicationServiceDelegate> _Nonnull)delegate trace:(BTRACE * _Nonnull)trace;

/// 结束轨迹服务
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.stopTrace(self, trace: traceInstance)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] stopTrace:self trace:traceInstance];
/// 
/// </code>
/// \param delegate 遵循 <code>ApplicationServiceDelegate
/// </code> 协议的对象。结束轨迹服务的结果会通过 <code>onStopTrace(_:errMsg:)
/// </code> 方法进行回调
///
/// \param trace <code>BTRACE
/// </code> 类的对象
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationServiceDelegate
/// </code> 协议中的 <code>onStopTrace(_:errMsg:)
/// </code> 回调方法获取
- (void)stopTrace:(id <ApplicationServiceDelegate> _Nonnull)delegate trace:(BTRACE * _Nonnull)trace;

/// 在轨迹服务开启后改变采集和打包周期。在轨迹服务开启之前设置采集和打包周期，使用 BTRACE 类中的 setInterval 方法
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.changeGatherAndPackIntervalsAfterStartTrace(self, gatherInterval:5, packInterval:30)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] changeGatherAndPackIntervalsAfterStartTrace:self gatherInterval:5 packInterval:10];
/// 
/// </code>
/// <h3>Note:</h3>
/// 新的采集周期和打包周期仍然需要满足 <code>BTRACE
/// </code> 类中的 <code>setInterval(_:packInterval:)
/// </code> 方法中对采集和打包周期大小的限制条件
///
/// \param delegate 遵循 <code>ApplicationServiceDelegate
/// </code> 协议的对象。更改周期的结果会通过 <code>onChangeGatherAndPackIntervalsAfterStartTrace(_:errMsg:)
/// </code> 方法进行回调
///
/// \param gatherInterval 新的采集周期
///
/// \param packInterval 新的打包周期
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationServiceDelegate
/// </code> 协议中的 <code>onChangeGatherAndPackIntervalsAfterStartTrace(_:errMsg:)
/// </code> 回调方法获取
- (void)changeGatherAndPackIntervalsAfterStartTrace:(id <ApplicationServiceDelegate> _Nonnull)delegate gatherInterval:(int32_t)gatherInterval packInterval:(int32_t)packInterval;

/// 设置定位相关的属性
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.setAttributeOfLocation(1, desiredAccuracy:1, distanceFilter:10)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] setAttributeOfLocation:1 desiredAccuracy:1 distanceFilter:10];
/// 
/// </code>
/// <h3>Note:</h3>
/// <ul><li>本方法应该在开始轨迹服务之前调用，开启轨迹服务之后调用不会起作用</li><li>本方法没有返回值，可以认为设置后一定会成功</li><li>需要的定位精度越高、触发定位的距离阈值越低，电量消耗越大。</li><li>绝大部分情况下不需要调用此方法</li></ul>
/// \param activityType 定位设备的活动类型 0代表步行，1代表汽车，2代表火车高铁等，3代表其他
///
/// \param desiredAccuracy 需要的定位精度 0代表最高定位精度，此选项定位最为精确，适用于导航等场景，只有手机插上电源才有效； 1代表米级别的定位精度，是不插电源情况下的最高定位精度；2代表十米级别的定位精度；3代表百米级别的定位精度；4代表千米级别的定位精度；5代表最低定位精度，偏移可能达到几公里以上
///
/// \param distanceFilter 触发定位的距离阈值, 单位是米
- (void)setAttributeOfLocation:(NSInteger)activityType desiredAccuracy:(NSInteger)desiredAccuracy distanceFilter:(double)distanceFilter;

/// 查询所有符合条件的entity信息及其实时位置，查询结果会通过 ApplicationEntityDelegate 协议的 onQueryEntityList(_:) 回调方法得到
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.queryEntityList(self, serviceId:100001, entityNames:"entity1,entity2", columnKey:"k1=v1,k2=v2", activeTime:1442824667, returnType:0, pageSize:20, pageIndex:1)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] queryEntityList:self serviceId:100001 entityNames:@"entity1,entity2" columnKey:@"k1=v1,k2=v2" activeTime:1442824667 returnType:0 pageSize:20 pageIndex:1];
/// 
/// </code>
/// <h3>Note:</h3>
/// <ul><li>由于activeTime, pageSize, pageIndex字段中0没有意义，所以都以0作为默认值</li><li>String类型的字段使用Optional(String)类型</li><li>如果需要查询多个entity，则entity_names字段的格式为："entity1,entity2,entity3" entity_name之间用英文逗号分开</li><li>如果查询时不需要通过自定义属性进行检索，columnKey字段的值为nil；如果要通过多个自定义属性进行检索，columnKey字段的格式为"k1=v1,k2=v2"，其中k1和k2必须是事先通过鹰眼webapi的<a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/entity#addcolumn.E2.80.94.E2.80.94.E6.B7.BB.E5.8A.A0entity.E5.B1.9E.E6.80.A7.E5.AD.97.E6.AE.B5">entity/addcolumn</a>接口添加好的可检索的属性字段</li></ul>
/// \param delegate 遵循 <code>ApplicationEntityDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param entityNames 要检索的entity_name集合, 如果要同时检索多个entity，写成"entity1,entity2,entity3"的形式，entity之间用英文逗号分开
///
/// \param columnKey 开发者自定义的entity属性字段
///
/// \param activeTime 活跃时间（UNIX时间戳），检索在此之间点之后还有轨迹上传的entity。不需要指定时传入0
///
/// \param returnType 返回结果的类型。0代表返回完整的结果，1代表只返回entity_name字段。默认值为0
///
/// \param pageSize 分页大小，指定返回的每页中包含几条结果，最大值为1000。不需要指定时传入0，目前会返回100条结果
///
/// \param pageIndex 分页索引，指定返回全部符合条件的结果的第几页，从1开始。不需要指定时传入0，目前会返回第一页的结果
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationEntityDelegate
/// </code> 协议中的 <code>onQueryEntityList(_:)
/// </code> 回调方法获取
- (void)queryEntityList:(id <ApplicationEntityDelegate> _Nonnull)delegate serviceId:(long long)serviceId entityNames:(NSString * _Nullable)entityNames columnKey:(NSString * _Nullable)columnKey activeTime:(NSInteger)activeTime returnType:(NSInteger)returnType pageSize:(NSInteger)pageSize pageIndex:(NSInteger)pageIndex;

/// 创建一个新的entity（实体对象），结果会通过 ApplicationEntityDelegate 协议的 onAddEntity(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.addEntity(self, serviceId:100001, entityName:"entity1", columnKey:"k1=v1,k2=v2")
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] addEntity:self serviceId:100001 entityName:@"entity1" columnKey:@"k1=v1,k2=v2"];
/// 
/// </code>
/// <h3>Note:</h3>
/// <ul><li>entity（实体对象）可以是一个人、一辆车、或任何一个可以被记录轨迹的对象。在查询任何entity的实时位置、历史轨迹之前，都必须先创建这个entity。</li><li>entity的创建有2种途径，一种是通过调用<code>addEntity
/// </code>方法主动添加；另一种是在实例化 <code>BTRACE
/// </code> 类时，指定一个名称，调用startTrace后如果网络畅通成功登录到服务端，则会在服务端自动创建一个以这个名称命名的entity，但服务端自动创建的这个entity不包含自定义属性的值。如果需要指定这个entity的自定义属性的值，还需要手动调用 <code>updateEntity(_:serviceId:entityName:columnKey:)
/// </code> 方法，通过其<code>columnKey
/// </code>字段指定这个entity的自定义属性的值。</li><li>通过此方法添加的entity，可以通过iOSSDK，安卓SDK，webapi等方式查询。</li><li>如果只是想简单地记录“entity1”的轨迹，那么完全可以以“entity1”作为实体名称实例化BTRACE，然后调用startTrace，利用服务端自动创建的entity，然后在查询实时位置和历史轨迹的时候，指定“entity1”即可。如果只是需要创建一个实体，而暂时不需要记录这个实体的轨迹，可以手动调用本方法，比如创建地理围栏时需要指定的<code>creator
/// </code>参数和<code>monitor_person
/// </code>参数。</li><li>columnKey字段用于指定新创建的实体的自定义属性的值。假设有一些物流配送人员需要管理，可以设置columnKey字段的值为“region=haidian,gender=male”就是指定新创建的这个实体的地区属性为海淀区，性别属性为男。需要注意的是，这里的region和gender属性必须先通过鹰眼webapi的<a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/entity#addcolumn.E2.80.94.E2.80.94.E6.B7.BB.E5.8A.A0entity.E5.B1.9E.E6.80.A7.E5.AD.97.E6.AE.B5">entity/addcolumn</a>接口进行添加。</li><li>如果这两个属性是可检索的，以后调用 <code>queryEntityList(_:serviceId:entityNames:columnKey:activeTime:returnType:pageSize:pageIndex:)
/// </code> 方法时，columnKey字段指定为“gender=male”时，这个entity就会被检索出来。如果不是可检索的，只会在 <code>queryEntityList(_:serviceId:entityNames:columnKey:activeTime:returnType:pageSize:pageIndex:)
/// </code> 方法的返回中展示出来而已，并不能用来检索。</li></ul>
/// \param delegate 遵循 <code>ApplicationEntityDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param entityName 要添加的实体对象的名称
///
/// \param columnKey 新添加的这个实体对象的属性及其值
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationEntityDelegate
/// </code> 协议中的 <code>onAddEntity(_:)
/// </code> 回调方法获取
- (void)addEntity:(id <ApplicationEntityDelegate> _Nonnull)delegate serviceId:(long long)serviceId entityName:(NSString * _Nonnull)entityName columnKey:(NSString * _Nullable)columnKey;

/// 更新一个entity（实体对象）的一个或多个属性的值，结果会通过 ApplicationEntityDelegate 协议的 onUpdateEntity(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.updateEntity(self, serviceId:100001, entityName:"entity1", columnKey:"k1=v1,k2=v2")
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] updateEntity:self serviceId:100001 entityName:@"entity1" columnKey:@"k1=v1,k2=v2"];
/// 
/// </code>
/// <h3>Note:</h3>
/// <ul><li>entityName字段对应的实体对象，必须是已经存在的。要么是通过开启轨迹服务后服务端自动创建的，要么是通过addEntity方法自己手动创建的。</li><li>columnKey字段用于指定需要修改的自定义属性的值，仍以addEntity中的物流配送场景为例，如果将这里的columnKey字段设置为“region=chaoyang”就是将这个实体的地区属性修改为朝阳区。这里的region必须是已有的属性字段，要么是在addEntity时创建的属性字段，要么是通过webapi的<a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/entity#addcolumn.E2.80.94.E2.80.94.E6.B7.BB.E5.8A.A0entity.E5.B1.9E.E6.80.A7.E5.AD.97.E6.AE.B5">entity/addcolumn</a>接口添加的属性字段。</li></ul>
/// \param delegate 遵循<code>ApplicationEntityDelegate
/// </code>协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param entityName 要更新的实体对象的名称
///
/// \param columnKey 需要更新的这个实体对象的属性及其值
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationEntityDelegate
/// </code> 协议中的 <code>onUpdateEntity(_:)
/// </code> 回调方法获取
- (void)updateEntity:(id <ApplicationEntityDelegate> _Nonnull)delegate serviceId:(long long)serviceId entityName:(NSString * _Nonnull)entityName columnKey:(NSString * _Nullable)columnKey;

/// 查询某个实体对象在指定时间段内的历史轨迹数据，结果会通过 ApplicationTrackDelegate 协议的 onGetHistoryTrack(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.getTrackHistory(self, serviceId:100001, entityName:"entity1", startTime:1442119825, endTime:1442159825, simpleReturn:1, isProcessed:0, pageSize:1000, pageIndex:1)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] getTrackHistory:self serviceId:100001 entityName:@"entity1" startTime:1442119825 endTime:1442159825 simpleReturn:1 isProcessed:0 pageSize:1000 pageIndex:1];
/// 
/// </code>
/// <h3>Note:</h3>
/// <ul><li>endTime不得小于startTime，且endTime最大不得超过startTime+86400</li><li>历史轨迹的查询只能指定唯一的entityName，无法同时查询多个entity的历史轨迹。</li><li>本方法中无法指定轨迹纠偏选项、排序方式等，建议使用重载过的<code>getTrackHistory(_:serviceId:entityName:startTime:endTime:simpleReturn:isProcessed:processOption:supplementMode:sortType:pageSize:pageIndex:)
/// </code> 方法</li></ul>
/// \param delegate 遵循 <code>ApplicationTrackDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param entityName 要查询的实体对象的名称
///
/// \param startTime 起始时间（UNIX时间戳）
///
/// \param endTime 结束时间（UNIX时间戳）
///
/// \param simpleReturn 是否返回精简结果  0代表返回原始结果，1代表返回精简结果，2代表只返回本段轨迹的里程。
///
/// \param isProcesed 是否返回纠偏后轨迹  0为返回原始轨迹，1为返回纠偏后的轨迹。
///
/// \param pageSize 返回结果中每页有几条数据。0代表不指定，最大值为5000，默认返回100条。
///
/// \param pageIndex 返回结果的第几页。0代表不指定，默认返回第1页。
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationTrackDelegate
/// </code> 协议中的 <code>onGetHistoryTrack(_:)
/// </code> 回调方法获取
- (void)getTrackHistory:(id <ApplicationTrackDelegate> _Nonnull)delegate serviceId:(long long)serviceId entityName:(NSString * _Nonnull)entityName startTime:(long long)startTime endTime:(long long)endTime simpleReturn:(NSInteger)simpleReturn isProcessed:(NSInteger)isProcessed pageSize:(NSInteger)pageSize pageIndex:(NSInteger)pageIndex;

/// 重载的历史轨迹查询方法，可以指定轨迹纠偏的选项、里程补偿方式、结果排序方式。结果会通过 ApplicationTrackDelegate 协议的 onGetHistoryTrack(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.getTrackHistory(self, serviceId:100001, entityName:"entity1", startTime:1442119825, endTime:1442159825, simpleReturn:1, isProcessed:0, processOption: "need_denoise=1,need_vacuate=1,need_mapmatch=0", supplementMode: "driving", sortType: 0, pageSize:1000, pageIndex:1)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] getTrackHistory:self serviceId:100001 entityName:@"entity1" startTime:1442119825 endTime:1442159825 simpleReturn:1 isProcessed:0 processOption: @"need_denoise=1,need_vacuate=1,need_mapmatch=0" supplementMode: @"driving" sortType: 0 pageSize:1000 pageIndex:1];
/// 
/// </code>
/// <h3>轨迹纠偏选项的说明</h3>
/// 轨迹纠偏选项的设置，仅在isProcessed=1时生效，通过为纠偏选项中各项赋1（需要）或0（不需要）来设置是否需要该项数据处理，支持的纠偏选项如下：
///
/// <ul><li>need_denoise：去噪，默认为1</li><li>need_vacuate：抽稀，默认为1</li><li>need_mapmatch：绑路（仅适用于驾车），之前未开通绑路的service，默认值为0；之前已开通绑路的service，默认值为1
/// 多选项设置时用英文逗号","分割，若不设置某选项则按默认值处理。
/// 如果想设置本段轨迹去燥、抽稀但是不绑路，可以指定本字段的值为："need_denoise=1,need_vacuate=1,need_mapmatch=0"</li></ul>
/// <h3>里程补偿方式的说明</h3>
/// 在里程计算时，两个轨迹点定位时间间隔5分钟以上，被认为是中断。
/// 中断轨迹提供以下5种里程估算方式：
///
/// <ul><li>no_supplement不补充，中断两点间距离不记入里程；</li><li>straight：使用直线距离补充；</li><li>driving：使用最短驾车路线距离补充；</li><li>riding：使用最短骑行路线距离补充；</li><li>walking：使用最短步行路线距离补充；
/// 如果传入nil代表不进行里程补充。</li></ul>
/// <h3>Note:</h3>
/// <ul><li>endTime不得小于startTime，且endTime最大不得超过startTime+86400</li><li>历史轨迹的查询只能指定唯一的entityName，无法同时查询多个entity的历史轨迹。</li><li><code>processOption
/// </code>轨迹纠偏选项只有当<code>isProcessed
/// </code>字段的值为1时才有效</li><li><code>supplementMode
/// </code>里程补充方式的生效不依赖于<code>isProcessed
/// </code>字段的值，如果要求返回全部结果，而且需要里程补充，那么返回的历史轨迹结果中，只有<code>distance
/// </code>字段的值是进行里程补充过的，不会添加具体的轨迹点到历史轨迹中去。</li></ul>
/// \param delegate 遵循 <code>ApplicationTrackDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param entityName 要查询的实体对象的名称
///
/// \param startTime 起始时间（UNIX时间戳）
///
/// \param endTime 结束时间（UNIX时间戳）
///
/// \param simpleReturn 是否返回精简结果  0代表返回原始结果，1代表返回精简结果，2代表只返回本段轨迹的里程。
///
/// \param isProcesed 是否返回纠偏后轨迹  0为返回原始轨迹，1为返回纠偏后的轨迹。
///
/// \param processOption 轨迹纠偏选项。
///
/// \param supplementMode 里程补偿方式。
///
/// \param sortType 结果排序方式。0代表返回的轨迹点按loc_time从大到小排序，1代表从小到大排序。
///
/// \param pageSize 返回结果中每页有几条数据。0代表不指定，最大值为5000，默认返回100条。
///
/// \param pageIndex 返回结果的第几页。0代表不指定，默认返回第1页。
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationTrackDelegate
/// </code> 协议中的 <code>onGetHistoryTrack(_:)
/// </code> 回调方法获取
- (void)getTrackHistory:(id <ApplicationTrackDelegate> _Nonnull)delegate serviceId:(long long)serviceId entityName:(NSString * _Nonnull)entityName startTime:(long long)startTime endTime:(long long)endTime simpleReturn:(NSInteger)simpleReturn isProcessed:(NSInteger)isProcessed processOption:(NSString * _Nullable)processOption supplementMode:(NSString * _Nullable)supplementMode sortType:(NSInteger)sortType pageSize:(NSInteger)pageSize pageIndex:(NSInteger)pageIndex;

/// 查询指定时间段内的里程(单位:米)。结果会通过 ApplicationTrackDelegate 协议的 onQueryDistance(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.queryDistance(self, serviceId:100001, entityName:"entity1", isProcessed:0, processOption: "need_denoise=1,need_vacuate=1,need_mapmatch=0", supplementMode: "driving", startTime:1442119825, endTime:1442159825)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] queryDistance:self serviceId:100001 entityName:@"entity1" isProcessed:1 processOption:@"need_denoise=1,need_vacuate=1,need_mapmatch=0" supplementMode:@"driving" startTime:1442119825 endTime:1442159825];
/// 
/// </code>
/// <h3>processOption参数的说明</h3>
/// 轨迹纠偏选项的设置，仅在is_processed=1时生效，通过为纠偏选项中各项赋1（需要）或0（不需要）来设置是否需要该项数据处理，支持的纠偏选项如下：
///
/// <ul><li>need_denoise：去噪，默认为1</li><li>need_vacuate：抽稀，默认为1</li><li>need_mapmatch：绑路（仅适用于驾车），之前未开通绑路的service，默认值为0；之前已开通绑路的service，默认值为1
/// 多选项设置时用英文逗号","分割，若不设置某选项则按默认值处理。
/// 如果想设置本段轨迹去燥、抽稀但是不绑路，可以指定本字段的值为："need_denoise=1,need_vacuate=1,need_mapmatch=0"</li></ul>
/// <h3>supplementMode参数的说明</h3>
/// 在里程计算时，两个轨迹点定位时间间隔5分钟以上，被认为是中断。
/// 中断轨迹提供以下5种里程估算方式：
///
/// <ul><li>no_supplement不补充，中断两点间距离不记入里程；</li><li>straight：使用直线距离补充；</li><li>driving：使用最短驾车路线距离补充；</li><li>riding：使用最短骑行路线距离补充；</li><li>walking：使用最短步行路线距离补充；
/// 如果传入nil代表不进行里程补充。</li></ul>
/// <h3>Note:</h3>
/// <ul><li>endTime不得小于startTime，且endTime最大不得超过startTime+86400</li><li>本方法实际是 <code>getTrackHistory(_:serviceId:entityName:startTime:endTime:simpleReturn:isProcessed:processOption:supplementMode:sortType:pageSize:pageIndex:)
/// </code> 方法中simpleReturn=2时的快捷方法，都是查询一段时间短内轨迹的里程</li></ul>
/// \param delegate 遵循 <code>ApplicationTrackDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param entityName 要查询的实体对象的名称
///
/// \param isProcesed 返回的里程是否考虑了轨迹的纠偏 0为原始轨迹的里程，1为纠偏后的轨迹的里程
///
/// \param processOption 返回的里程是否考虑了轨迹的纠偏
///
/// \param supplementMode 对里程进行补偿的方式
///
/// \param startTime 起始时间（UNIX时间戳）
///
/// \param endTime 结束时间（UNIX时间戳）
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationTrackDelegate
/// </code> 协议中的 <code>onQueryDistance(_:)
/// </code> 回调方法获取
- (void)queryDistance:(id <ApplicationTrackDelegate> _Nonnull)delegate serviceId:(long long)serviceId entityName:(NSString * _Nonnull)entityName isProcessed:(NSInteger)isProcessed processOption:(NSString * _Nullable)processOption supplementMode:(NSString * _Nullable)supplementMode startTime:(long long)startTime endTime:(long long)endTime;

/// 创建一个圆形的服务端地理围栏。结果会通过 ApplicationFenceDelegate 协议的 onCreateFence(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.createCircularFence(self, serviceId: 100001, fenceName: "fenceA", fenceDesc: "围栏A", creator: "entity1", monitoredPersons: "entity2", observers: "entity3", validTimes: "0000,2359", validCycle: 4, validDate: nil, validDays:nil, coordType: 3, center: "116.4321,38.76623", radius: 50.5, alarmCondition: 3, precision: 100)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] createCircularFence:self serviceId:100001 fenceName:@"fenceA" fenceDesc:@"围栏A" creator:@"entity1" monitoredPersons:@"entity2" observers:@"entity3" validTimes:@"0000,2359" validCycle:4 validDate:nil validDays:nil coordType:3 center:@"116.4321,38.76623" radius:50.5 alarmCondition:3 precision:100];
/// 
/// </code>
/// <h3>Note:</h3>
/// 通过本方法创建的服务端地理围栏，当此围栏的被监控对象触发了围栏报警时，报警信息会通过<code>ApplicationServiceDelegate
/// </code>协议的<code>onPushTrace(_:errMsg:)
/// </code>方法回调。\See 
///
/// 
/// <code>onCreateFence(_:)
/// </code>
///
/// \param delegate 遵循 <code>ApplicationFenceDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param fenceName 地理围栏的名称
///
/// \param fenceDesc 地理围栏的描述
///
/// \param creator 地理围栏的创建者，创建者必须是一个已经存在的entity（实体对象）
///
/// \param monitoredPersons 地理围栏的监控对象，监控对象必须是一个已经存在的entity（实体对象），只有这个监控对象的轨迹才会触发这个地理围栏的报警
///
/// \param observers 地理围栏的观察者，观察者必须是一个已经存在的entity（实体对象），且只有这个观察者才会收到该地理围栏的报警推送
///
/// \param validTimes 围栏生效时间列表; 格式为"string,string;string,string;…"; 一天中的几点几分到几点几分生效。至少含有一段生效时间，多个时间段使用分号”;”分隔。比如：“0820,0930;1030,1130”
///
/// \param validCycle 围栏生效周期; int; 标识validTimes是否周期性生效，可以使用如下数值 1：不重复 2：工作日循环 3：周末循环 4：每天循环 5：自定义 当为5时，需要定义valid_days，标识在周几生效。当validCycle为1时，必须设置validDate字段，当validCycle为5时，必须设置validDays字段。
///
/// \param validDate 围栏生效日期; 当valid_cycle为1时必须设置此字段的值，例如：20150908。
///
/// \param validDays 围栏生效日期列表; 格式为"int,int..."; 1到7，分别表示周一到周日，当valid_cycle为5时必须设置此字段的值。
///
/// \param coordType 圆形地理围栏圆心的坐标类型; 坐标类型定义如下：1：GPS经纬度 2：国测局经纬度 3：百度经纬度
///
/// \param center 圆形地理围栏圆心的经纬度; 格式为：“经度,纬度”; 示例："116.4321,38.76623"
///
/// \param radius 圆形地理围栏的半径; 单位：米。
///
/// \param alarmCondition 地理围栏报警条件; 1：进入时触发提醒 2：离开时触发提醒 3：进入离开均触发提醒
///
/// \param precision 地理围栏去燥的精度; 当采集到的轨迹点的定位精度超过此阈值时，将不会触发围栏. 如果需要所有的轨迹点，无论定位精度是多少都去触发围栏计算, 设置为0（可能造成围栏误报警）
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onCreateFence(_:)
/// </code> 回调方法获取
- (void)createCircularFence:(id <ApplicationFenceDelegate> _Nonnull)delegate serviceId:(long long)serviceId fenceName:(NSString * _Nonnull)fenceName fenceDesc:(NSString * _Nullable)fenceDesc creator:(NSString * _Nonnull)creator monitoredPersons:(NSString * _Nonnull)monitoredPersons observers:(NSString * _Nonnull)observers validTimes:(NSString * _Nonnull)validTimes validCycle:(NSInteger)validCycle validDate:(NSString * _Nullable)validDate validDays:(NSString * _Nullable)validDays coordType:(NSInteger)coordType center:(NSString * _Nonnull)center radius:(double)radius alarmCondition:(NSInteger)alarmCondition precision:(NSInteger)precision;

/// 创建一个多边形的服务端地理围栏。结果会通过 ApplicationFenceDelegate 协议的 onCreateFence(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.createVertexesFence:self, serviceId:100001, fenceName:"fenceB", fenceDesc:"围栏B", creator:"entity1", monitoredPersons:"entity2", observers:"entity3", validTimes:"0000,2359", validCycle:4, validDate:nil, validDays:nil, coordType:3, vertexes:"119.32,40.38;119.33,40.38;119.33,40.37", alarmCondition:3, precision:100)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] createVertexesFence:self serviceId:100001 fenceName:@"fenceB" fenceDesc:@"围栏B" creator:@"entity1" monitoredPersons:@"entity2" observers:@"entity3" validTimes:@"0000,2359" validCycle:4 validDate:nil validDays:nil coordType:3 vertexes:@"119.32,40.38;119.33,40.38;119.33,40.37" alarmCondition:3 precision:100];
/// 
/// </code>
/// <h3>Note:</h3>
/// 通过本方法创建的服务端地理围栏，当此围栏的被监控对象触发了围栏报警时，报警信息会通过<code>ApplicationServiceDelegate
/// </code>协议的<code>onPushTrace(_:errMsg:)
/// </code>方法回调。
///
/// \param delegate 遵循 <code>ApplicationFenceDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param fenceName 地理围栏的名称
///
/// \param fenceDesc 地理围栏的描述
///
/// \param creator 地理围栏的创建者，创建者必须是一个已经存在的entity（实体对象）
///
/// \param monitoredPersons 地理围栏的监控对象，监控对象必须是一个已经存在的entity（实体对象），只有这个监控对象的轨迹才会触发这个地理围栏的报警
///
/// \param observers 地理围栏的观察者，观察者必须是一个已经存在的entity（实体对象），且只有这个观察者才会收到该地理围栏的报警推送
///
/// \param validTimes 围栏生效时间列表; 格式为"string,string;string,string;…"; 一天中的几点几分到几点几分生效。至少含有一段生效时间，多个时间段使用分号”;”分隔。比如：“0820,0930;1030,1130”
///
/// \param validCycle 围栏生效周期; int; 标识validTimes是否周期性生效，可以使用如下数值 1：不重复 2：工作日循环 3：周末循环 4：每天循环 5：自定义 当为5时，需要定义valid_days，标识在周几生效。当validCycle为1时，必须设置validDate字段，当validCycle为5时，必须设置validDays字段。
///
/// \param validDate 围栏生效日期; 当valid_cycle为1时必须设置此字段的值，例如：20150908。
///
/// \param validDays 围栏生效日期列表; 格式为"int,int..."; 1到7，分别表示周一到周日，当valid_cycle为5时必须设置此字段的值。
///
/// \param coordType 多边形地理围栏的顶点坐标的坐标类型; 坐标类型定义如下：1：GPS经纬度 2：国测局经纬度 3：百度经纬度
///
/// \param vertexes 多边形地理围栏的顶点坐标列表（顶点为多边形顺时针或逆时针顺序，格式: "经度,纬度;....")
///
/// \param alarmCondition 地理围栏报警条件; 1：进入时触发提醒 2：离开时触发提醒 3：进入离开均触发提醒
///
/// \param precision 地理围栏去燥的精度; 当采集到的轨迹点的定位精度超过此阈值时，将不会触发围栏. 如果需要所有的轨迹点，无论定位精度是多少都去触发围栏计算, 设置为0（可能造成围栏误报警）
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onCreateFence(_:)
/// </code> 回调方法获取
- (void)createVertexesFence:(id <ApplicationFenceDelegate> _Nonnull)delegate serviceId:(long long)serviceId fenceName:(NSString * _Nonnull)fenceName fenceDesc:(NSString * _Nullable)fenceDesc creator:(NSString * _Nonnull)creator monitoredPersons:(NSString * _Nonnull)monitoredPersons observers:(NSString * _Nonnull)observers validTimes:(NSString * _Nonnull)validTimes validCycle:(NSInteger)validCycle validDate:(NSString * _Nullable)validDate validDays:(NSString * _Nullable)validDays coordType:(NSInteger)coordType vertexes:(NSString * _Nonnull)vertexes alarmCondition:(NSInteger)alarmCondition precision:(NSInteger)precision;

/// 创建一个客户端地理围栏。结果会通过 ApplicationFenceDelegate 协议的 onCreateLocalFence(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>let center = CLLocationCoordinate2D(latitude: 40.0, longitude: 116.0)
/// let localFence = BLocalFence(name: "fenceA", center: center, coordType: 3, radius: 10, accuracy: 10)
/// BTRACEAction.shared.createLocalFence(self, fence: localFence)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>CLLocationCoordinate2D center = CLLocationCoordinate2DMake(40.0, 116.0);
/// BLocalFence* localFence = [[BLocalFence alloc] initWithName:@"fenceB" center:center coordType:3 radius:50 accuracy: 50];
/// [[BTRACEAction shared] createLocalFence:self fence:localFence];
/// 
/// </code>
/// <h3>Note:</h3>
/// 通过本方法创建的客户端地理围栏，当本设备触发了围栏时，报警信息会通过<code>ApplicationServiceDelegate
/// </code>协议的<code>onPushTrace(_:errMsg:)
/// </code>方法回调。
///
/// \param delegate 遵循 <code>ApplicationFenceDelegate
/// </code> 协议的对象
///
/// \param fence 客户端地理围栏的对象
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onCreateLocalFence(_:)
/// </code> 回调方法获取
- (void)createLocalFence:(id <ApplicationFenceDelegate> _Nonnull)delegate fence:(BLocalFence * _Nonnull)fence;

/// 删除一个客户端地理围栏，结果会通过 ApplicationFenceDelegate 协议的 onDeleteLocalFence(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.deleteLocalFence(self, fenceId: [1,2])
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>NSArray* fenceIds = [[NSArray alloc] init];
/// [[BTRACEAction shared] deleteLocalFence:self fenceId:fenceIds];
/// 
/// </code>
/// \param delegate 遵循 <code>ApplicationFenceDelegate
/// </code> 协议的对象
///
/// \param fenceId 要删除的客户端地理围栏id的数组, 数组中有哪些fenceId就删除对应的本地围栏，若想删除所有的本地围栏，传入空数组即可
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onDeleteLocalFence(_:)
/// </code> 回调方法获取
- (void)deleteLocalFence:(id <ApplicationFenceDelegate> _Nonnull)delegate fenceId:(NSArray<NSNumber *> * _Nonnull)fenceId;

/// 更新服务端地理围栏。结果会通过 ApplicationFenceDelegate 协议的 onUpdateFence(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.updateFence(self, serviceId:100001, fenceId:1, fenceName:"fenceC", fenceDesc:"围栏C", monitoredPersons:"entity3", observers:"entity3", validTimes:"0800,2200", validCycle:4, validDate:nil, validDays:nil, shape:1, coordType:3, center:"119.33,40.37", radius:15.5, vertexes:nil, alarmCondition:3, precision:10)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] updateFence:self serviceId:100001 fenceId:1 fenceName:@"fenceC" fenceDesc:@"围栏C" monitoredPersons:@"entity3" observers:@"entity3" validTimes:@"0800,2200" validCycle:4 validDate:nil validDays:nil shape:1 coordType:3 center:@"119.33,40.37" radius:15.5 vertexes:nil alarmCondition:3 precision:10];
/// 
/// </code>
/// \param delegate 遵循 <code>ApplicationFenceDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param fenceName 修改后的地理围栏的名称，不需要修改传nil
///
/// \param fenceDesc 修改后的地理围栏的描述，不需要修改传nil
///
/// \param monitoredPersons 修改后的地理围栏的监控对象不需要修改传nil，监控对象必须是一个已经存在的entity（实体对象），只有这个监控对象的轨迹才会触发这个地理围栏的报警
///
/// \param observers 修改后的地理围栏的观察者，不需要修改传nil，观察者必须是一个已经存在的entity（实体对象），且只有这个观察者才会收到该地理围栏的报警推送
///
/// \param validTimes 修改后的围栏生效时间列表，不需要修改传nil; 格式为"string,string;string,string;…"; 一天中的几点几分到几点几分生效。至少含有一段生效时间，多个时间段使用分号”;”分隔。比如：“0820,0930;1030,1130”
///
/// \param validCycle 修改后的围栏生效周期; int; 标识validTimes是否周期性生效，可以使用如下数值 1：不重复 2：工作日循环 3：周末循环 4：每天循环 5：自定义 当为5时，需要定义valid_days，标识在周几生效。当validCycle为1时，必须设置validDate字段，当validCycle为5时，必须设置validDays字段。
///
/// \param validDate 修改后的围栏生效日期; 当valid_cycle为1时必须设置此字段的值，例如：20150908。
///
/// \param validDays 修改后的围栏生效日期列表; 格式为"int,int..."; 1到7，分别表示周一到周日，当valid_cycle为5时必须设置此字段的值。
///
/// \param shape 修改后的地理围栏类型。 1代表将围栏更新为圆形, 2代表将围栏更新为多边形
///
/// \param coordType 修改后的地理围栏的坐标类型; 坐标类型定义如下：1：GPS经纬度 2：国测局经纬度 3：百度经纬度
///
/// \param center 只有shape＝1时才有效，代表修改后的地理围栏为圆形，地理围栏圆心的经纬度; 格式为：“经度,纬度”; 示例："116.4321,38.76623"
///
/// \param radius 只有shape＝1时才有效，代表修改后的地理围栏为圆形，地理围栏的半径; 单位：米。
///
/// \param vertexes 只有shape＝2时才有效，代表修改后的地理围栏为多边形，地理围栏的顶点坐标列表（顶点为多边形顺时针或逆时针顺序，格式: "经度,纬度;....")
///
/// \param alarmCondition 修改后的地理围栏报警条件; 1：进入时触发提醒 2：离开时触发提醒 3：进入离开均触发提醒
///
/// \param precision 修改后的地理围栏去燥的精度; 当采集到的轨迹点的定位精度超过此阈值时，将不会触发围栏. 如果需要所有的轨迹点，无论定位精度是多少都去触发围栏计算, 设置为0（可能造成围栏误报警）
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onUpdateFence(_:)
/// </code> 回调方法获取
- (void)updateFence:(id <ApplicationFenceDelegate> _Nonnull)delegate serviceId:(long long)serviceId fenceId:(long long)fenceId fenceName:(NSString * _Nullable)fenceName fenceDesc:(NSString * _Nullable)fenceDesc monitoredPersons:(NSString * _Nullable)monitoredPersons observers:(NSString * _Nullable)observers validTimes:(NSString * _Nullable)validTimes validCycle:(NSInteger)validCycle validDate:(NSString * _Nullable)validDate validDays:(NSString * _Nullable)validDays shape:(NSInteger)shape coordType:(NSInteger)coordType center:(NSString * _Nullable)center radius:(double)radius vertexes:(NSString * _Nullable)vertexes alarmCondition:(NSInteger)alarmCondition precision:(NSInteger)precision;

/// 删除指定的服务端地理围栏。结果会通过 ApplicationFenceDelegate 协议的 onDeleteFence(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.deleteFence(self, serviceId:100001, fenceId:1)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] deleteFence:self serviceId:100001 fenceId:1];
/// 
/// </code>
/// \param delegate 遵循 <code>ApplicationFenceDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param fenceId 创建服务端地理围栏时分配的围栏唯一标识符
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onDeleteFence(_:)
/// </code> 回调方法获取
- (void)deleteFence:(id <ApplicationFenceDelegate> _Nonnull)delegate serviceId:(long long)serviceId fenceId:(long long)fenceId;

/// 查询已创建的服务端地理围栏。结果会通过 ApplicationFenceDelegate 协议的 onFenceList(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.queryFenceList(self, serviceId:100001 creator:nil fenceIds:"1,2")
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] queryFenceList:self serviceId:100001 creator:@"entityA" fenceIds:nil];
/// 
/// </code>
/// <h3>Require</h3>
/// <ul><li>查询时creator和fenceIds至少要指定一个</li><li>有fenceIds列表时按id列表查找，若没有指定id列表，则按创建者查找</li><li>fenceIds列表中最多可以有10项</li></ul>
/// \param delegate 遵循 <code>ApplicationFenceDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param creator 围栏的创建者
///
/// \param fenceIds 围栏的id列表，格式为"int,int,int"
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onFenceList(_:)
/// </code> 回调方法获取
- (void)queryFenceList:(id <ApplicationFenceDelegate> _Nonnull)delegate serviceId:(long long)serviceId creator:(NSString * _Nullable)creator fenceIds:(NSString * _Nullable)fenceIds;

/// 查询某个服务端地理围栏的某个监控对象，在指定时间短内的历史报警信息。查询结果会通过 ApplicationFenceDelegate 协议的 onQueryFenceHistoryAlarm(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.queryFenceHistoryAlarm(self, serviceId:100001, fenceId:1, monitoredPersons:"entityA", beginTime:1471239000, endTime:1471249000)
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] queryFenceHistoryAlarm:self serviceId:100001 fenceId:1 monitoredPersons:@"entityA" beginTime:1471239000 endTime:1471249000];
/// 
/// </code>
/// \param delegate 遵循 <code>ApplicationFenceDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param fenceId 创建服务端地理围栏时分配的唯一标识符
///
/// \param monitoredPersons 指定地理围栏监控的实体对象的名称列表，格式为“entityA,entityB”，最多设置5个实体对象，如果希望查询所有被监控对象的历史报警，传入nil
///
/// \param beginTime 开始时间（UNIX时间戳）
///
/// \param endTime 结束时间（UNIX时间戳）
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onQueryFenceHistoryAlarm(_:)
/// </code> 回调方法获取
- (void)queryFenceHistoryAlarm:(id <ApplicationFenceDelegate> _Nonnull)delegate serviceId:(long long)serviceId fenceId:(long long)fenceId monitoredPersons:(NSString * _Nullable)monitoredPersons beginTime:(long long)beginTime endTime:(long long)endTime;

/// 查询指定的服务端地理围栏下指定的监控对象当前在围栏内还是围栏外。查询结果会通过 ApplicationFenceDelegate 协议的 onQueryFenceStatus(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.queryFenceStatus(self, serviceId:100001, fenceId:1, monitoredPersons:"entityA,entityB")
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] queryFenceStatus:self serviceId:100001 fenceId:1 monitoredPersons:@"entityA,entityB"];
/// 
/// </code>
/// \param delegate 遵循 <code>ApplicationFenceDelegate
/// </code> 协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param fenceId 创建服务端地理围栏时分配的唯一标识符
///
/// \param monitoredPersons 指定需要查询的被监控实体对象的名称列表，格式为“entityA,entityB”，最多设置5个实体对象，需要查询此围栏下所有被监控对象的状态时，传入nil
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onQueryFenceStatus(_:)
/// </code> 回调方法获取
- (void)queryFenceStatus:(id <ApplicationFenceDelegate> _Nonnull)delegate serviceId:(long long)serviceId fenceId:(long long)fenceId monitoredPersons:(NSString * _Nullable)monitoredPersons;

/// 假定被监控对象的位置信息，查询此时被监控对象在指定服务端围栏的内部还是外部。查询结果会通过 ApplicationFenceDelegate 协议的 onQueryFenceStatus(_:) 回调方法得到。
///
/// <h3>Usage Example</h3>
/// <blockquote>Swift</blockquote>
/// <code>BTRACEAction.shared.queryFenceStatus(self, serviceId:100001, fenceId:1, monitoredPersons:"entityA,entityB")
/// 
/// </code>
/// <blockquote>Objective-C</blockquote>
/// <code>[[BTRACEAction shared] queryFenceStatusByLocation:self serviceId:100001 fenceId:1 monitoredPersons:@"entityA,entityB" locations:@"116.314461,40.047682,3;116.4321,38.76623,3"];
/// 
/// </code>
/// <h3>Require</h3>
/// <ul><li>locations中可以指定多个位置坐标，分别与<code>monitoredPersons
/// </code>中指定的被监控实体对象的名称列表对应</li><li>locations中坐标之间用英文分号";"分隔，每个坐标内部包含经度、纬度、坐标类型，他们之间用英文逗号','分隔。</li><li>locations中的坐标类型定义如下：1代表WGS84经纬度 2代表国测局经纬度 3代表百度经纬度</li></ul>
/// \param delegate 遵循<code>ApplicationFenceDelegate
/// </code>协议的对象
///
/// \param serviceId 鹰眼轨迹管理台创建鹰眼服务时分配的service_id
///
/// \param fenceId 创建服务端地理围栏时分配的唯一标识符
///
/// \param monitoredPersons 指定需要查询的被监控实体对象的名称列表，格式为“entityA,entityB”，最多设置5个实体对象
///
/// \param locations 被监控实体对象对应的位置信息，格式为“entityA的经度,entityA的纬度,坐标类型;entityB的经度,entityB的纬度,坐标类型”
///
/// \returns  本方法为异步方法，执行结果通过 <code>ApplicationFenceDelegate
/// </code> 协议中的 <code>onQueryFenceStatus(_:)
/// </code> 回调方法获取
- (void)queryFenceStatusByLocation:(id <ApplicationFenceDelegate> _Nonnull)delegate serviceId:(long long)serviceId fenceId:(long long)fenceId monitoredPersons:(NSString * _Nullable)monitoredPersons locations:(NSString * _Nullable)locations;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface NSData (SWIFT_EXTENSION(BaiduTraceSDK))
@end


@interface NSNull (SWIFT_EXTENSION(BaiduTraceSDK))
@end


@interface NSNumber (SWIFT_EXTENSION(BaiduTraceSDK))
@end


@interface NSURL (SWIFT_EXTENSION(BaiduTraceSDK))
@end


@interface NSURLComponents (SWIFT_EXTENSION(BaiduTraceSDK))
@end


@interface NSURLRequest (SWIFT_EXTENSION(BaiduTraceSDK))
@end


@interface NSURLRequest (SWIFT_EXTENSION(BaiduTraceSDK))
@end


@interface NSURLSession (SWIFT_EXTENSION(BaiduTraceSDK))
@end

#pragma clang diagnostic pop
